###创建对象的方式
类加载检查 分配内存空间 初始化零值 初始化对象头 执行init方法

####可达性检查  
> GCRoots（根）  
1. 虚拟机栈中引用的对象（线程栈变量）  
2. 方法区静态引用的对象（静态变量）  
3. 常量引用的对象（常量池）  
4. native引用的对象（JNI指针）  

> 四种对象的引用
1. 强引用  
2. 软引用 softRference（系统将要发生outofmemory前，回收，若内存仍不够，仍抛出outofmemory）--缓存  
3. 弱引用 weekReference（垃圾回收器扫描时，不论是否会发生outofmemory，都会回收）--缓存  
4. 虚引用 phantomReference--垃圾回收器功能自检  
###判断对象是否存活

**GC的回收条件**：哪个区域满了，对哪个区域垃圾回收

minorGC（yongGC）（新生代GC）   FullGC majorGC（老年代回收）

> 对象的分配原则
1. 栈上分配（逃逸分析--如果确定一个对象不会逃逸出线程之外，那么让对象在栈上分配内存可以提高 JVM 的效率）
2. 对象优先分配在eden区
3. 大对象优先进入老年代
4. 长期存活的对象进入老年代
5. 动态对象年龄判断   某一个年龄超过Survivor大小的一半，会将相等或超过此年龄的进入老年区
6. 空间分配担保：发生minorGC前，判断老年代剩余空间是否大于新生代空间，大于直接进行minorGC，否则需要先进行majorGC。  
    * 有担保，则判断老年代空间是否大于历次平均minorGC空间，若大于，则直接进行minorGC。若此次不够，触发majorGC。

> CMS垃圾回收器（老年代）
* 采用标记-清除算法  
    1. 初始标记  
    2. 并发标记  
    3. 重新标记  
    减少了标记的时间（减少了STW stop the world）
    ***
    4. 并发清除
*问题
    1. CPU敏感-----4核以下很敏感  
    2. 浮动垃圾-----（清除时多线程，会继续产生垃圾）老年代不能全部利用，而且可能会触发serial  
    3. 空间碎片

> Garbage First（G1）垃圾优先
* 划分很多相等的块，region，可表达为eden Survivor old Humongos(大对象,等同于老年代处理)区。
    1. 初始标记
    2. 并发标记（新对象有TAMS-- at mark start--region指向此标记）漏标---通过快照STAB（snapshot-at-the-beginning）解决
    3. 最终标记
    4. 筛选回收